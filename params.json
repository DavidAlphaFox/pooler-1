{"name":"Pooler","tagline":"A Fast, Thread-Safe Pooling Library for Common Lisp.","body":"Pooler\r\n======\r\n\r\nA Trivial, Fast, Thread-Safe Pooling Library for Common Lisp.\r\n\r\nWe need pools for items which have heavy cost of creation and which we can reuse.\r\nA typical use case is connection pools.\r\n\r\nPool item creation (as required) is automatic on fetch-from pool. Pool-item's are created and destroyed using user supplied funcitons. The pool has a idle timeout after which all the existing pool-item's are destroyed and new ones created (pool-init). The pool has a threshold number of items which it tries to maintain.\r\n\r\nLicence : MIT\r\n\r\n\r\nAPI\r\n---\r\n\r\n*Structure* **POOL**\r\n```\r\nNAME             : Is a text string identifying the POOL\r\nQUEUE            : A queue to store the POOL-ITEMs\r\nPOOL-LOCK        : A lock we hold when we want to update the POOL\r\nITEM-MAKER       : A function which returns a POOL-ITEM.\r\nITEM-DESTROYER   : A function which sanely destroys a POOL-ITEM\r\nCAPACITY         : The max number of POOL-ITEMs to store in the POOL\r\nTHRESHOLD        : The min number of POOL-ITEMs we should ideally keep in the POOL.\r\nTIMEOUT          : The number of seconds of idleness after which the POOL will be re-init.\r\nLAST-ACCESS      : The last access time for the POOL.\r\nCURRENT-SIZE     : The current number of POOL-ITEMs in the POOL\r\nTOTAL-USES       : Total number of times the POOL-ITEMs have been taken out of the POOL\r\nTOTAL-CREATED    : Total number of new POOL-ITEMs created and added to the POOL\r\nTOTAL-POOL-INITS : How many times the POOL was 'INIT'.\r\n```\r\n\r\n---\r\n\r\n**make-pool** &key *name* *max-capacity* *min-threshold* *pool-item-maker* *pool-item-destroyer*\r\n\r\nMakes and returns a new POOL.\r\n\r\n---\r\n\r\n**grow-pool** *pool* &optional *grow-by*\r\n\r\nCreates and adds POOL-ITEMs to the *pool*. In case *grow-by* is not provided then it takes ( *threshold* *pool* ) as the value\r\n\r\n---\r\n\r\n**fetch-from-aux** *pool*\r\n\r\nFetches a POOL-ITEM from the POOL. Tell us if the pool has become old.\r\n\r\n---\r\n\r\n**fetch-from** *pool* &key (*tries 3*)\r\n\r\nIs a wrapper around *fetch-from-aux* and will try *tries* number of times to fetch POOL-ITEM from POOL. In case POOL-ITEM is not returned then it grows the POOL and tries again.\r\n\r\n---\r\n\r\n**return-to** *pool* *pool-item*\r\n\r\nReturns a POOL-ITEM to the POOL. In case the pool is at CAPACITY the POOL-ITEM will be sanely destroyed using the given function\r\n\r\n---\r\n\r\n**pool-init** *pool*\r\n\r\nSanely destroys all the POOL-ITEMS and then re-creates THRESHOLD number of POOL-ITEMS.\r\n\r\n---\r\n\r\n**with-pool** *pool-item* *pool* &body body\r\n\r\nExecutes the body where *pool-item* is fetched from the *pool* and available. Sanely returns *pool-item* to the *pool* on finish of body.\r\n\r\n\r\nExamples\r\n--------\r\n\r\n\tPOOLER> (defvar *x* nil)\r\n\t*X*\r\n\tPOOLER> (setf *x* (make-pool :name \"Test Pool\"))\r\n\t#<POOL Test Pool Max:4 Current:0 >\r\n\tPOOLER> (fetch-from+ *x*)\r\n\tSAMPLE-ITEM\r\n\tPOOLER> *x*\r\n\t#<POOL Test Pool Max:4 Current:1 >\r\n\tPOOLER> (return-to *x* **)\r\n\t2\r\n\tPOOLER> (with-pool (pool-item *x*) (print pool-item))\r\n\tSAMPLE-ITEM\r\n\tSAMPLE-ITEM\r\n\tPOOLER> *x*\r\n\t#<POOL Test Pool Max:4 Current:2 >\r\n\r\nAnother\r\n\r\n    CL-USER> (pooler:make-pool :item-maker #'(lambda () (clsql:connect '(\"127.0.0.1\" \"quasidb\" \"quasi\" \"*****\")\r\n                                                                        :database-type :mysql\r\n                                                                        :if-exists :new))\r\n                               :item-destroyer #'(lambda (item) (clsql:disconnect :database item)))\r\n    #S(POOLER::POOL\r\n      :NAME \"Default Pool\"\r\n      :QUEUE #S(SB-CONCURRENCY:QUEUE\r\n      :HEAD (SB-CONCURRENCY::.DUMMY.)\r\n      :TAIL (SB-CONCURRENCY::.DUMMY.)\r\n      :NAME NIL)\r\n      :LOCK #<SB-THREAD:MUTEX \"Pool Lock\" (free)>\r\n      :ITEM-MAKER #<FUNCTION (LAMBDA #) {1005C9BFAB}>\r\n      :ITEM-DESTROYER #<FUNCTION (LAMBDA #) {1005CCAAAB}>\r\n      :CAPACITY 40\r\n      :THRESHOLD 2\r\n      :TIMEOUT 300\r\n      :LAST-ACCESS 0\r\n      :CURRENT-SIZE 0\r\n      :TOTAL-USES 0\r\n      :TOTAL-CREATED 0\r\n      :TOTAL-POOL-INITS 0)\r\n    CL-USER> (defvar *mysql-pool* *)\r\n    CL-USER> (pooler:fetch-from *mysql-pool*)\r\n    #<CLSQL-MYSQL:MYSQL-DATABASE 127.0.0.1/quasidb/quasi OPEN {1007571373}>\r\n    CL-USER> (pooler:return-to *mysql-pool* *)\r\n    2\r\n    CL-USER> (pooler:with-pool (db *mysql-pool*) (clsql:query \"show tables;\" :database db))\r\n    ((\"LOGIN_DATA\"))\r\n    (\"Tables_in_quasidb\")\r\n\r\n\r\nAuthor\r\n------\r\nAbhijit Rao a.k.a quasi\r\n\r\nquasi@quasilabs.in\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}